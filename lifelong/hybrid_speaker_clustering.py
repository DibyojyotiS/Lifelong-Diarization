# -*- coding: utf-8 -*-
"""Hybrid-Speaker-Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dnUoNaOMpRPIWT0vUEgTpUTwLn8Pgf9i
"""

import numpy as np
import tensorflow as tf
from scipy import spatial


"""Distance Calculator"""

def cos_distance(L1, L2):
    """
        Compute cosine distance between L1 and L2
        shape of L1, L2 = 1 x D (np-array)
    """
    result = spatial.distance.cosine(L1, L2)
    return result

"""Dispersion Calculator"""

"""
    Compute cluster dispersion
    shape of covariance_matrices = C x D x D (np-array)
    shape of n_embds = C x 1 (np-array)
"""
def cluster_dispersion(covariance_matrices, n_embds):
    
    result = np.zeros(covariance_matrices[0].shape)
    for i in range(len(n_embds)):
        result += n_embds[i]*(covariance_matrices[i])
    result = np.linalg.det(result)    
    result = result*np.sqrt([len(n_embds)])
    return result

def cluster_dispersion1(centroids, covariance_matrices, n_embds, embd, j):

    n_embds[j] = n_embds[j] + 1
    k = n_embds[j]
    covariance_matrices[j] = ((k-1)/(k))*covariance_matrices[j] + (1/k)*np.matmul(np.transpose(embd-centroids[j]), embd-centroids[j])
    return cluster_dispersion(covariance_matrices, n_embds)

def cluster_dispersion2(covariance_matrices, n_embds, embd):

    covariance_matrices = np.vstack((covariance_matrices, [np.zeros(covariance_matrices[0].shape)]))
    n_embds = np.vstack((n_embds, [1]))
    return cluster_dispersion(covariance_matrices, n_embds)

"""Parameter Updater"""

"""
    shape of centroids = C x D (np-array)
    shape of covariance_matrices = C x D x D (np-array)
    shape of n_embds = C x 1
    shape embd = 1 x D
"""
def update_params_j(embd, centroids, covariance_matrices, n_embds, j):

    # global centroids
    # global covariance_matrices
    # global n_embds

    n_embds[j] += 1
    k = n_embds[j]
    centroids[j] = (centroids[j]*(k-1) + embd)/k
    covariance_matrices[j] = ((k-1)/(k))*covariance_matrices[j] + (1/(k-1))*np.matmul(np.transpose(embd-centroids[j]), embd-centroids[j])
    
    return centroids, covariance_matrices, n_embds

def update_params_new(embd, centroids, covariance_matrices, n_embds):

    # global centroids
    # global covariance_matrices
    # global n_embds
    
    if len(centroids) == 0: centroids = np.array([embd])
    else: centroids = np.vstack((centroids, [embd]))
    
    if len(n_embds) == 0: n_embds = np.array([[1]])
    else: n_embds = np.vstack((n_embds, [[1]]))
    
    if len(covariance_matrices) == 0: 
        d = embd.shape[1]
        covariance_matrices = np.array([np.zeros((d, d))])
    else: covariance_matrices = np.vstack((covariance_matrices, [np.zeros(covariance_matrices[0].shape)]))
    
    return centroids, covariance_matrices, n_embds
        

"""Embeddings Classifier"""

def classify_new_embeds(embd, centroids, covariance_matrices, n_embds, min_threshold = 0.5, max_threshold = 1):

    # global centroids
    # global covariance_matrices
    # global n_embds

    """
        embds = embedding needed to be classified, shape = 1 x D
        centroids = centroid of all speakers, shape = C x D
        covariances = covariance matrix of all speakers, shape = C x D x D
        n_embds = number of embeds corresponding to each speaker, shape = C x 1
    """

    j = 0
    
    if len(centroids) == 0:
        centroids, covariance_matrices, n_embds = update_params_new(embd, centroids, covariance_matrices, n_embds)
        j = len(n_embds)-1
        return j, centroids, covariance_matrices, n_embds
    
    min_D = cos_distance(embd, centroids[0])
    for i in range(1, len(centroids)):
        D = cos_distance(embd, centroids[i])
        if (D<min_D):
            j = i
            min_D = D

    if (min_D < min_threshold):
        centroids, covariance_matrices, n_embds = update_params_j(embd, centroids, covariance_matrices, n_embds, j)

    elif (min_D > max_threshold):
        centroids, covariance_matrices, n_embds = update_params_new(embd, centroids, covariance_matrices, n_embds)
        j = len(n_embds)-1

    else:
        G1 = cluster_dispersion1(centroids, covariance_matrices, n_embds, embd, j) 
        G2 = cluster_dispersion2(covariance_matrices, n_embds, embd) 

        if (G1 < G2):
            centroids, covariance_matrices, n_embds = update_params_j(embd, centroids, covariance_matrices, n_embds, j)

        else:
            centroids, covariance_matrices, n_embds = update_params_new(embd, centroids, covariance_matrices, n_embds)
            j = len(n_embds)-1

    return j, centroids, covariance_matrices, n_embds